package streaming

trait SimpleStream[+A] {
  var evaluated= 0  // only relevant for the toString method 
                    // flag that expresses whether the tail or the head is evaluated or not  
	def isEmpty: Boolean
	def head: A
	def tail: ()=> SimpleStream[A]
	def toString_r:String= { if (isEmpty) "" else
	  if (evaluated==1) ", "+head+ tail().toString_r else 
	    if (evaluated==2) ", "+head.toString+", ?" else ", ?"}

	def take(n: Int): SimpleStream[A] = this match {
    case Cons(_,_) if n > 1  => SimpleStream.cons(head, tail().take(n - 1))
    case Cons(_,_) if n == 1 => SimpleStream.cons(head, SimpleStream.empty)
    case _                   => SimpleStream.empty
}
	
 def filter(p: A => Boolean): SimpleStream[A] =
    if (isEmpty) this
      else if (p(head)) SimpleStream.cons(head, tail().filter(p))
        else tail().filter(p)
        
 def map[O](f:A=>O):SimpleStream[O]= this match{
      case Cons(_,_) => SimpleStream.cons({f(head)}, tail().map(f))
      case _ => SimpleStream.empty
   }

 def toList: List[A] = {
    def extract(s: SimpleStream[A]): List[A] = s match {
      case Cons(h, t) =>  h :: extract(s.tail())
      case _          => Nil
    }
    extract(this)
 }
 
 override def equals(s:Any):Boolean=  
   if (s.isInstanceOf[SimpleStream[A]]){
     val el=s.asInstanceOf[SimpleStream[A]]
     if (el.isEmpty && isEmpty) true
       else if (el.isEmpty && !isEmpty) false
         else if (!el.isEmpty && isEmpty) false
           else {
             val el=s.asInstanceOf[Cons[A]]
             if (head!=el.head) false
               else tail().equals(el.tail())
           }
   }
   else false
 
 /*******************************************************************************************  
 
    Write a function apply that extracts the nth element
 
    If n is greater than the length of a Stream, throw an Error
 
 *******************************************************************************************/
 
   def apply(n:Int):A = this match {
     
     case Cons(_,_) if (n == 0) => head
     case Cons(_,_) if( n > 0) => tail().apply(n-1)
     case _ => throw new Error("element not found")
     
   }
 
 /*******************************************************************************************  
 
    Write a function fold that aggregates all elements 
 
    starting with a base element.
 
 *******************************************************************************************/     
 
 def fold[S](base:S)(foldFun:(S,A)=>S):S= ???
 
 /*******************************************************************************************  
 
    Write a function startsWith that tests whether a stream
 
    has a prefix s.
 
 *******************************************************************************************/
 
 def startsWith[A](s:SimpleStream[A]): Boolean= ???
 
}

case object Empty extends SimpleStream[Nothing]{
  
  def isEmpty=true
  def head = throw new Error("Stream is empty")
	def tail = throw new Error("Stream is empty")
  override def toString= "SimpleStream.Empty"
}

case class Cons[+A](hd: A, tl: ()=> SimpleStream[A]) extends SimpleStream[A]{
 
  def tail= {evaluated=1;tl}
  def head= {if (evaluated==0) evaluated=2;hd}
  def isEmpty=false  
  override def toString= "SimpleStream("+head+{if (evaluated==1) tail().toString_r else ", ?"}+")" 
}

object SimpleStream {
	def cons[T](hd: T, tl: => SimpleStream[T]) = 	{
   lazy val tail = tl
   new Cons[T](hd, ()=>tail )
	}
	val empty = Empty 
	def apply[A] (as:A*):SimpleStream[A] =
  		if (as.isEmpty) SimpleStream.empty else SimpleStream.cons(as.head, apply(as.tail: _*))
  		
 /*******************************************************************************************  
 
    Write a function createStreamRange that create a Stream with numbers from
    start to end.
    
    If start is greater than n the Stream should be empty
 
 *******************************************************************************************/
 
 def createStreamRange(start:Int, end:Int): SimpleStream[Int]= ???
 
 /*******************************************************************************************  
 
    Write a function createStream that creates a Stream with base as
 
    the first element. All other elements should be generated by the function next.
 
 *******************************************************************************************/
     
 def createStream[T](base:T)(next:T=>T):SimpleStream[T]= ???
 

	/*******************************************************************************************  
 
    Write a function createStreamGen that creates a Stream with next(base)._1 as
 
    the first element. All other elements should also be generated by the function next.
    
    The function next should have the following structure: It takes an element of type T 
    
    (corresponds to the base element type) and it returns a tuple consisting of:
    
    *   an element of type T to generate the next element and
    *   an element of type S to take it as the head element of a Stream.
 
 *******************************************************************************************/
 def createStreamGen[T,S](base:T)(next:T=>(T,S)):SimpleStream[S]= ???
} 

